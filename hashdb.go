package hashdb

import (
	"encoding/binary"
	"fmt"
	"io/ioutil"
	"os"
	"reflect"
	"syscall"
	"unsafe"
)

var primes = []uint64{
	7,
	11,
	19,
	37,
	67,
	113,
	193,
	331,
	563,
	967,
	1657,
	2819,
	4793,
	8161,
	13873,
	23593,
	40111,
	68207,
	115963,
	197137,
	335149,
	569759,
	968593,
	1646609,
	2799239,
	4758707,
	8089817,
	13752701,
	23379599,
	39745319,
	67567091,
	114864059,
	195268963,
	331957243,
	564327347,
	959356547,
	1630906177,
	2772540503,
	4713318893,
	8012642153,
	13621491703,
	23156535937,
	39366111097,
	66922388873,
	113768061101,
	193405703917,
	328789696673,
	558942484349,
	950202223409,
	1615343779807,
	2746084425691,
	4668343523687,
	7936183990283,
	13491512783501,
	22935571732013,
	38990471944439,
	66283802305549,
	0,
}

var rtable = []uint64{
	7161894671141868069,
	2026477282954470369,
	2429508451144552337,
	17635849675291803701,
	11131238007097670752,
	14575476040221120054,
	9448375414748162182,
	2454672299959216175,
	9038789348187905929,
	10933259439552310726,
	2604799974320421089,
	5824527580030745861,
	5125964867552333118,
	1032915946974892656,
	7131376882090382684,
	14307526071761074839,
	3292238237244544521,
	17717635889128793053,
	7823470298035437952,
	1975366557820174427,
	10130351589661861436,
	9571000392841473940,
	6202913113537891909,
	16922673442642735572,
	2156829192340373188,
	17495964840236106615,
	13101909516477009795,
	4817099012745200872,
	14440198504627065274,
	14651729576330546182,
	16980202802087429883,
	12900263937584820877,
	2306027069114081229,
	1780864555642068862,
	9043601808960553234,
	15810640748094581704,
	17810874749899385925,
	4370190832352558107,
	17458810291480308649,
	17137251597030639508,
	10210885020493337176,
	6152269424340619539,
	10958960557696769058,
	8165460651316620468,
	12486315176958405201,
	17592774145591647916,
	8342048574340997121,
	3154714627493747480,
	15876451744546896617,
	343989707369051175,
	18365325630196641291,
	2477841560223049522,
	3898012761994223425,
	13369082662290243962,
	15815494733174249928,
	6304647780032933422,
	10269137979996697992,
	6277295857270470928,
	6000011608783271869,
	13901041329075672746,
	5669978874985545944,
	5455469485091664306,
	65335843055329217,
	7934898480926769168,
	1273073282087458907,
	16888695346150306798,
	8377368602892110731,
	1830469377103303016,
	17077332288245307211,
	5023390539089620699,
	14022792370712725528,
	13636537031872854434,
	7870715805107021553,
	9484630489072256949,
	1785134210141330253,
	8281677267421262728,
	15726046893482748791,
	1797508209107071112,
	12663465705322475788,
	8481880801368525635,
	4369078805123407981,
	903851902053625478,
	7837494259996271178,
	2168514567018919298,
	6219073417129656739,
	1609380567131206125,
	5153501301389604643,
	3896838726756759252,
	8715831947034564606,
	2079854376561616185,
	3912231126093865119,
	10987109511229875092,
	5769717256290699511,
	13634152406859624118,
	16659329366647962799,
	6409336122833332638,
	2789121606213559319,
	11317161666220426030,
	5185355556384359463,
	8442664884098488832,
	7076397050218785674,
	10088557173876904389,
	7360073205936248365,
	16451313490277755438,
	9084450421159417912,
	7348057751024665700,
	10777225389799347258,
	17763690326796380653,
	2891266716373283937,
	3655130714223786187,
	7755701151370365925,
	2212513937006372504,
	13523931701650912532,
	12113220208962200812,
	9881595722024476612,
	23002422026741603,
	17107233953671023105,
	12923193250737842924,
	17273319855552890761,
	9133832377885676104,
	9902895775500395847,
	7159708893808326203,
	9615663095357430075,
	1173681393331973473,
	10048050401369270562,
	3613131142636259446,
	8860752244643660461,
	8399862844187873110,
	11183016300248525601,
	1652501197644627033,
	15778225670129936072,
	16574295115244112702,
	4071749887734109238,
	17813113169857863668,
	5866933485061915213,
	2617207803875766346,
	4927492731270466097,
	7688280036888791740,
	10563928654676671801,
	5936083376618012629,
	2075718064826528220,
	9759600056023457767,
	3395252869081930520,
	9580020404503428349,
	15488920383895635663,
	13904943215446818750,
	6352674340782198596,
	14778579765560499187,
	1164565579755687793,
	9437615470246010305,
	12898414888770350367,
	11725805952345397029,
	2006395968798208907,
	6768413660762254955,
	14184745999655108007,
	7813559219758021899,
	18324113513585059371,
	7085574629681949288,
	431441848559906543,
	464267230845345911,
	1723783827948552176,
	13062030383763489855,
	17331570881699461752,
	4623703904617640360,
	12154158654629278230,
	11380594816064729611,
	11043398968000652485,
	16839635851508053491,
	8035951356794912228,
	13812221149347752777,
	16687823876032983453,
	12787887064839641354,
	5607226621089666635,
	14689718028345080763,
	6624890426811243934,
	3028949181253016309,
	6065105387082590706,
	7160481282251925368,
	3358207170046758608,
	17630673089168148155,
	64927047284298113,
	904966882733558578,
	1287129322554954815,
	1075294316230729903,
	1878565720252146877,
	5685951107830131172,
	3952290001879195657,
	735398701777187064,
	13776332351172973742,
	5037200310196218445,
	9527386686783206461,
	7649393134260975078,
	12061883647515108400,
	485526623820713506,
	10291959463983135641,
	12243304422703205549,
	8572879391592600851,
	12173591873149535986,
	5819027826014763350,
	7427024978563219025,
	14870798251933491692,
	3706320956350599471,
	13766394013514711397,
	13924654713711829920,
	171503584564545799,
	16183518851605836502,
	14630157969039086483,
	15510815886551585460,
	95398970168327875,
	14978281303351638957,
	16546380181433032989,
	12520318463248954619,
	6573340268706252253,
	3265740609522436520,
	5573960834668842001,
	8691344533374800877,
	754361571041746766,
	15161242727912943940,
	4862135978370040353,
	18077714108297608008,
	7011244222376967230,
	11314094752631247342,
	7838448989574755374,
	1085364298322250198,
	917401104898565019,
	18427172238462792360,
	2166707018289349654,
	1790273621506854230,
	11519979079560744544,
	13573964173325008866,
	17754380141665606138,
	6000314738465890293,
	6299478196153293038,
	1360744789613898708,
	2715087463067748498,
	8615301479886349946,
	6325907209709099700,
	5508742753589735059,
	15045665041620723592,
	7641618366800420587,
	8017941082372145823,
	12827110062020410768,
	16212098331480246028,
	10114390025762652463,
	7792159807616260057,
	16490297273177275624,
	2894344997890487060,
	14703898115432444100,
	3209020746801030043,
	7938173398119607796,
	3756451239655888427,
	11339389497709461975,
	13313028615130553489,
	14181252301152349881,
	4872007803117399842,
	17412432177095593973,
	0, /* sentinel */
}

func getNewSizeForSlots(numSlots uint64) uint64 {
	minSlots := numSlots * 2
	i := uint64(0)
	for primes[i] < minSlots {
		i++
	}
	n := primes[i]
	cap := n / 2
	return (n + cap + 1) * 24
}

type Entry struct {
	Key    uint64
	Offset uint64
	Length int32
	flags  int32
}

const (
	DEFAULT_SLOT = 968593
)

func (e *Entry) IsEmpty() bool {
	return e.flags&1 == 0
}
func OpenIndex(path string)(*Db,error){
     db:=&Db{fileName:path}
	err:=db.Open()
	return db,err
}

type Db struct {
	fileName   string
	fd         int
	file       *os.File
	data       []Entry
	mmhandle   []byte
	slotsUsed  *uint64
	totalSlots uint64
}

func (db *Db) FileName() string {
	return db.fileName
}

func (db *Db) Open() error {
	f, err := os.OpenFile(db.fileName, os.O_CREATE|os.O_RDWR, 0644)
	if err != nil {
		return err
	}
	return db.open(f)
}
func (db *Db) open(f *os.File) error {
	db.fd = int(f.Fd())
	db.file = f
	st, err := db.file.Stat()
	if err != nil {
		return err
	}
	if st.Size() == 0 {
		sz := getNewSizeForSlots(DEFAULT_SLOT)
		syscall.Ftruncate(db.fd, int64(sz))
		db.mmap(int(sz))
	} else {
		db.mmap(int(st.Size()))
	}
	return nil
}

func (db *Db) resize(size int) error {
	return syscall.Ftruncate(db.fd, int64(size))
}

func (db *Db) mmap(size int) error {
	data, err := syscall.Mmap(db.fd, 0, size, syscall.PROT_WRITE|syscall.PROT_READ, syscall.MAP_SHARED)
	if err != nil {
		return err
	}
	header := (*reflect.SliceHeader)(unsafe.Pointer(&data))
	header.Len /= 24
	header.Cap = header.Len
	db.data = *(*[]Entry)(unsafe.Pointer(header))
	db.mmhandle = data
	head := &db.data[0]
	db.slotsUsed = &head.Key
	db.totalSlots = uint64(size/24) - 1
	return nil
}
func (db *Db) incrSlots() {
	*db.slotsUsed = (*db.slotsUsed) + 1
}

func (db *Db) Close() error {
	db.file.Sync()
	db.data = nil
	syscall.Munmap(db.mmhandle)
	db.file.Close()
	return nil
}

func (db *Db) entryAt(idx int) *Entry {
	return &db.data[idx]
}
func genTempTable(size uint64) (*Db, error) {
	db := &Db{}
	f, err := ioutil.TempFile("", "ht")
	if err != nil {
		return nil, err
	}
	syscall.Ftruncate(int(f.Fd()), int64(size))
	db.fileName = f.Name()
	db.open(f)
	db.mmap(int(size))
	return db, nil
}

func (db *Db) scale(newSlotSize uint64) {
	fmt.Println("RESCALE", newSlotSize)
	size := getNewSizeForSlots(newSlotSize)
	newTable, _ := genTempTable(size)
	for slot := range db.data[1:] {
		if !db.data[slot].IsEmpty() {
			newTable.Upsert(&db.data[slot])
		}
	}
	fmt.Println("REPLACE")
	newTable.Close()
	db.Close()
	os.Rename(newTable.FileName(), db.FileName())
	fmt.Println("OPEN")
	db.Open()
	fmt.Println("DONE")
}

func (db *Db) hashKey(before uint64) uint64 {
	hash := uint64(5381)
	var next uint64
	ba := make([]byte, 8)
	binary.LittleEndian.PutUint64(ba, before)

	for _, b := range ba {
		next = uint64(b)
		next = rtable[next]
		hash *= 33
		hash ^= next
	}
	return hash
}

func (db *Db) Fetch(key uint64) (*Entry, bool) {
	h := db.hashKey(key)%db.totalSlots + 1
	for i := uint64(0); i < db.totalSlots; i++ {
		et := db.entryAt(int(h))
		if et.Key == key {
			return et, true
		}
		if et.IsEmpty() {
			return nil, false
		}
		h++
		if h == db.totalSlots+1 {
			h = 1
		}
	}
	return nil, false
}

func (db *Db) Dump() {
	x := 0
	for i := range db.data {
		if i == 0 {
			fmt.Println("HEADER Slots Used:", db.data[i].Key, len(db.data)-1)
		} else {
			if !db.data[i].IsEmpty() {
				x++
				fmt.Println(x, i, db.data[i].Key)
			}
		}
	}
}

func (db *Db) Upsert(value *Entry) {
	/* Max load is 50% */
	if db.totalSlots/2 <= *db.slotsUsed {
		db.scale(*db.slotsUsed + 1)
	}
	h := db.hashKey(value.Key)%db.totalSlots + 1
	for {
		et := db.entryAt(int(h))
		if et.IsEmpty() {
			et.Key = value.Key
			et.Offset = value.Offset
			et.Length = value.Length
			et.flags |= 1
			db.incrSlots()
			break
		} else if et.Key == value.Key {
			et.Offset = value.Offset
			et.Length = value.Length
			return
		}
		h++
		if h == db.totalSlots+1 {
			h = 1
		}
	}

}
